---
title: "An Introduction to INLA-SPDE in R"
author: "Misha Tseitliani"
date: "2025-11-25"
output: html_document
bibliography: refINLA.bib
csl: nature.csl
---

# Background

At this point, we have gone through a number of methods for processing spatial data. Many of these were **non-parametric** or **semi-parametric**: this means that it can be difficult to link specific changes in a parameter or covariate to the intended result. In addition, many have been **spatially implicit**: they use coordinates as a proxy for spatial structure rather than modelling some *true space*. INLA can do all these too but is especially powerful for **parametric** and **spatially explicit** models. If you want to conduct inference on your data, then this might be perfect for you!

## Definitions

Before going too deep into the package details, first we need to ensure we're familiar with the language of spatial statistics. The point is not to teach theory (which will mostly be omitted) but to ensure we have a *shared language* when questions arise. If you *are* interested in the theory, there are numerous good [resources](https://www.paulamoraga.com/book-spatial/) out there.[@blangiardo_spatial_2015; @moraga_geospatial_2019; @moraga_spatial_2023]

INLA is theoretically inspired by hierarchical and state space models and has both **latent** and **observed** processes:

* **latent process**: the *true* environmental reality (e.g., number of species in a sampling plot). Also called a **state process**.
* **observation process**: what we see with our data (e.g., the number of species *recorded* in a sampling plot). With a normal model, this is what you are looking at.

With that sorted, spatial modelling has vocabulary corresponding to the geospatial language you know (and maybe love):

* **(Poisson) point process**: a 2D distribution for **vector data** and the basis of many geospatial models.
* **Cox process**: a doubly stochastic Poisson process for **vector data** where the intensity (i.e., expected number of points in a specific area) is itself stochastically random. INLA has special functions for Cox and LGCP (log-Gaussian Cox process) models.
* **Gaussian random field**: a continuous 2D field for **raster data**. In essence, fields are the **latent process** from which you draw distributions (via sampling).
* **Gauss-Markov random field (GMRF)**: a Gaussian random field for **raster data** where values structurally depend on some specific distance, time, etc (i.e., Markovian dependencies) but are otherwise independent.

To reiterate, INLA's spatial models are directly based on GMRFs, and point process models are treated as drawn from some latent GMRF. This means that you can always include raster data (e.g., as covariates) directly in your models even if your response is vector data.

### So, INLA?

**Integrated Nested Laplace Approximations (INLA)** are a method of estimating Bayesian models that run faster than MCMC (Markov Chain Monte Carlo) while still generating similar results. Spatial models in the `INLA` package use the **SPDE (Stochastic Partial Differential Equations)** approach to better fit spatial structures: hence the name INLA-SPDE. These are fit over a spatial mesh using splines to again, run faster than MCMC. In practice, users need only specify a spatial mesh and regression formulation (i.e., INLA's models are linear additive regression models) to get results.

## Assumptions

As a general rule of thumb, INLA-SPDE models are more rigid, spatially explicit, and accessible than MCMC. They also run much faster. In exchange, they come with a few assumptions:

* **Stationarity**: the underlying stochastic process is space-invariant (and time-invariant in spatiotemporal models). This would mean that your latent field should have a consistent mean and variance across the sampling domain. In practice, `INLA` has a default parameter `alpha = 2` that lets SPDEs accommodate non-stationarity.[@ingebrigtsen_spatial_2014; @gomez-rubio_bayesian_2020]
* **Isotropy**: covariance depends only on the distance between points (i.e., the spatial field is rotation-invariant). This assumption is quite strict, but some exceptions (e.g., diffusion and barrier models) are possible using supplemental packages like `INLAspacetime`. If you want to model impassable barriers (e.g., fences), see [this vignette](https://eliaskrainski.github.io/INLAspacetime/articles/web/barrierExample.html) for more information. There is debate on how much this impacts edge/boundary effects, but best practice is to define your study area to be a bit larger just in case. [@lindgren_bayesian_2015]

These two major assumptions are largely theoretical and are often violated by real-world data and scientific publications. Just note them and move on if this happens to you.

Beyond those, simple models function similarly to GAMMs (generalised additive mixed models) and include those assumptions:

* **Conditional independence**: observations are independent aside from the specified spatial and covariate structures.
* **Appropriate mean-variance relationships**: you are using the correct distribution and specifying its parameters appropriately. Don't model binary data with a Gaussian, for example.
* **Link-scale linearity**: with the exception of more complicated hierarchical models, all your covariates will be in a single equation added together. Is this reasonable?
* **Separability (e.g., collinearity)**: *for inference only*, you should avoid adding multiple terms that correlate with each other. In practice, you'll end up with untrustworthy estimates for any term that has this problem.

### Bayesian Statistics: An Aside

Unlike many traditional regression models, `INLA` is Bayesian, which means that you can set priors at almost any step in the modelling. See the first chapter of [this handy online book](https://becarioprecario.bitbucket.io/inla-gitbook/ch-intro.html#bayesian-inference) if you want more equations (like Bayes Theorem) and theoretical explanations. As a cursory review, Bayesian models are made up of **priors**, **likelihoods**, and **posteriors**:

* **Priors** are initial beliefs about the stochastic processes (and can include specialised geographical knowledge gained from the field).
* **Likelihoods** are the output of the data-based evaluation. Frequentist regression results (i.e., `glm`, `nlme`, `lme4`) *are* the likelihood.
* **Posteriors** combine the prior and likelihood to give what we think is true reality.

A good rule of thumb is to **always prefer default priors unless you have a reason not to**. For advanced model tweaks though, it can get quite interesting. We will go through some prior checks at the end of our worked example to demonstrate how you can interpret if, for example, you're using the correct distribution family (e.g., Gaussian, Poisson). INLA priors often work through **hyperparameters**: e.g., $\mu$ and $\sigma$ in Gaussian distribution.

The most likely priors you might use for bigger datasets are **penalised complexity priors** which tell the posterior to prefer simpler models whenever possible. In practice, these help models fit faster (even though `INLA` is already fast), and you can interpret the posterior more easily.

# Worked Example

That's enough theory; let's apply this to real data. This section will walk through an INLA-SPDE modelling pipeline from package installation to model diagnostics and comparison.

### Package Installation

```{r global, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

First, we'll need `tidyverse`, `INLA`, `fmesher`, and `inlabru` packages for this example. `INLA`, however, is not on CRAN and must be downloaded manually. I provide one example, but other options are available at the [`inlabru` vignette](https://inlabru-org.github.io/inlabru/index.html) and the [`INLA` website](https://www.r-inla.org/download-install). These are **highly dependent on your operating system and ICT permissions on your computer** but ICT (or I) can help find an option that works. At my last check, the example below should work on a newer Windows laptop with no admin permissions.

```{r imports, eval = FALSE}
# install INLA following the online instructions
# Finn reccomends installing the testing version due to lots of updates recently
# but you can always replace with the stable version if you'd like
install.packages("INLA",repos=c(getOption("repos"),INLA="https://inla.r-inla-download.org/R/testing"), dep=TRUE) 

# install inlabru
install.packages("inlabru")
# install fmesher
install.packages("fmesher")
```

Now, we can get our working environment in order.

```{r setup, results = FALSE, message = FALSE, warning = FALSE}
# set working directory to the root folder of the project I'm working in 
setwd(here::here())

# activate the packages as needed
library(tidyverse)
library(INLA)
library(inlabru)
library(fmesher)
# anything spatial relies on sf
library(sf)
```

### Data Checks

We'll use the Kilpisj√§rvi data from previous examples to model species richness. `INLA` can handle NAs in covariate data but not in the response, so make sure to check for messier data! There is nothing of concern for us if we're modelling `species_rich` as our response.

```{r naTest, , message = FALSE}
# import the data
kjRaw <- read_csv("Kilpisjarvi.csv")

# NAs per column for the three columns of interest
t(kjRaw %>% select(c("Lat", "Lon", "species_rich")) %>% 
    summarise(across(everything(), ~ sum(is.na(.)))))
```
### Spatial Setup

You can skip this if you're fitting a non-spatial model (e.g., GLM or GLMM), but if you're stopping there then why use `INLA` in the first place?

First thing we need to do is set up the spatial structure in the data itself, because working with `sf` objects makes everything easier.

```{r data, results = FALSE}
# make spatial
kjGeo <- st_as_sf(kjRaw, 
                  coords = c("Lon", "Lat"),
                  crs = 4326)
```

SPDE models start with the mesh, implemented using `fmesher`. At its simplest, we can do this automatically with `sf` objects or raw coordinates. In general, the more mesh nodes there are, the longer the model will take to run. If you want to test lots of models without worrying too much about *how well the estimation works*, coarse meshes are best. 

`fmesher` started as a function within INLA, so older code uses slightly different syntax (more information on converting via the [vignette](https://inlabru-org.github.io/fmesher/articles/inla_conversion.html)). These days `fmesher` can be used to specify spatial fields for other packages like `tinyVAST` and `sdmTMB` too; other packages like `gllvm` and `Hmsc` are working on compatability.

We demonstrate a basic, default mesh using the base method. Some handy alternatives (all with the `loc =` argument):

* `loc = ` can generate spherical meshes for global models if given 3D coordinates. 2D coordinates are the norm for `sf` objects.
* `fm_nonconvex_hull()` works with non-convex spatial areas that defaults handle poorly.
* `fm_hexagon_lattice()` is Finn's recommendation for a baseline mesh but has been (in his words) ignored by most modellers because it wasn't the default nor in the vignettes until this year. It represents a spatially uniform sampling protocol.

```{r mesh, message = FALSE, fig.width = 10, fig.height = 8}
meshBasic <- fm_mesh_2d_inla(
  # you can also set this with a boundary shapefile (in sf format) using
  #boundary = kjBoundary
  # location or boundary, you can only pick one!
  loc = kjGeo$geometry, 
  # set map units inside and outside 
  max.edge = c(0.9, # smaller inner units give a more detailed mesh within the sampling area
               1), # smaller outer units give more detailed spatial estimates of boundary effects
  # you can also set this to a single number like if you aren't worried about edge effects, for example:
  #max.edge = 1
  # cutoff is equivalent to the min edge
  #cutoff = 2, 
  crs = fm_crs(kjGeo)
)

# plotting is easy; you should always visually confirm
meshPlot <- ggplot() + 
  geom_fm(data = meshBasic) + 
  geom_sf(data = kjGeo, size = 0.5, colour = "red") + 
  theme_bw()
meshPlot
```

Next, we make the SPDE object for spatial models. We again use the base function, but `inla.spde2.pcmatern` is a nice alternative when you're working with big data: you can set **penalised complexity priors** to avoid bloat in the spatial structure. Our data is quite compact already, so this isn't necessary here.

```{r spdeSetup, results = FALSE}
# Making SPDE
# Quantify distance between points and define Matern correlation on the mesh
# allows for penalised complexity priors
spde2D <- inla.spde2.matern(mesh = meshBasic)#, 
#prior.range = c(10, 0.5), 
#prior.sigma = c(.5, .5))#,
#alpha = 2) 
```

## Acknowledgements

Many of the links, references, and materials came from [Ben Swallow](https://ben-swallow-research.github.io/) during his supervison of my MSc dissertation. The theory and background relied on older slides from [Janine Illian](https://www.gla.ac.uk/schools/mathematicsstatistics/staff/janineillian/). Newer `inlabru` materials came from Finn Lindgren's [2025 `inlabru` course](https://inlabru-org.github.io/inlabruCourseMay2025/index.html).

# References
